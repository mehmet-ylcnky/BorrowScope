//! Error types and handling for the CLI

use colored::Colorize;
use std::error::Error as StdError;
use std::path::PathBuf;
use thiserror::Error;

pub type Result<T> = std::result::Result<T, CliError>;

#[derive(Error, Debug)]
#[allow(dead_code)]
pub enum CliError {
    #[error("File not found: {0}")]
    FileNotFound(PathBuf),

    #[error("Invalid file format: {0}")]
    InvalidFormat(String),

    #[error("Configuration error: {0}")]
    ConfigError(String),

    #[error("Execution failed: {0}")]
    ExecutionFailed(String),

    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),

    #[error("JSON error: {0}")]
    Json(#[from] serde_json::Error),

    #[error("TOML error: {0}")]
    Toml(#[from] toml::de::Error),

    #[error("Graph error: {0}")]
    Graph(String),

    #[error("Port {0} is already in use")]
    PortInUse(u16),

    #[error("Command not found: {0}")]
    CommandNotFound(String),

    #[error("Instrumentation failed: {0}")]
    InstrumentationError(String),

    #[error("Build failed: {0}")]
    BuildError(String),

    #[error("Validation failed: {0}")]
    ValidationError(String),

    #[error("{0}")]
    Other(String),
}

impl CliError {
    /// Get a helpful suggestion for this error
    pub fn suggestion(&self) -> Option<&str> {
        match self {
            CliError::FileNotFound(_) => {
                Some("Check the file path or run 'borrowscope run' first to generate tracking data")
            }
            CliError::PortInUse(port) => {
                if *port < 8000 {
                    Some("Try a higher port number with --port <PORT> (e.g., --port 8080)")
                } else {
                    Some("Try a different port with --port <PORT>")
                }
            }
            CliError::CommandNotFound(cmd) if cmd == "cargo" => {
                Some("Install Rust and Cargo from https://rustup.rs")
            }
            CliError::CommandNotFound(cmd) if cmd == "dot" || cmd == "graphviz" => {
                Some("Install Graphviz: https://graphviz.org/download/")
            }
            CliError::InvalidFormat(_) => {
                Some("Ensure the file is valid JSON generated by BorrowScope")
            }
            CliError::ConfigError(_) => {
                Some("Run 'borrowscope init' to create a valid configuration file")
            }
            CliError::BuildError(_) => {
                Some("Check your Cargo.toml and ensure all dependencies are available")
            }
            CliError::InstrumentationError(_) => {
                Some("Ensure your Rust code is syntactically correct")
            }
            _ => None,
        }
    }

    /// Get the error category for colored output
    pub fn category(&self) -> &str {
        match self {
            CliError::FileNotFound(_) => "File Error",
            CliError::InvalidFormat(_) => "Format Error",
            CliError::ConfigError(_) => "Configuration Error",
            CliError::ExecutionFailed(_) => "Execution Error",
            CliError::Io(_) => "I/O Error",
            CliError::Json(_) => "JSON Error",
            CliError::Toml(_) => "TOML Error",
            CliError::Graph(_) => "Graph Error",
            CliError::PortInUse(_) => "Network Error",
            CliError::CommandNotFound(_) => "Command Error",
            CliError::InstrumentationError(_) => "Instrumentation Error",
            CliError::BuildError(_) => "Build Error",
            CliError::ValidationError(_) => "Validation Error",
            CliError::Other(_) => "Error",
        }
    }
}

/// Print error with full chain and suggestions
pub fn print_error(error: &CliError) {
    eprintln!();
    eprintln!("{}", "‚îÅ".repeat(70).red());
    eprintln!("{} {}", error.category().red().bold(), "‚úó".red().bold());
    eprintln!("{}", "‚îÅ".repeat(70).red());
    eprintln!();
    eprintln!("  {}", error.to_string().bright_red());

    // Print error chain
    let mut source = error.source();
    let mut depth = 1;
    while let Some(err) = source {
        let indent = "  ".repeat(depth);
        eprintln!();
        eprintln!("  {} {}", "‚Ü≥".yellow(), "Caused by:".yellow().bold());
        eprintln!("  {}  {}", indent, err.to_string().yellow());
        source = err.source();
        depth += 1;
    }

    // Print suggestion if available
    if let Some(suggestion) = error.suggestion() {
        eprintln!();
        eprintln!("{}", "‚îÄ".repeat(70).bright_black());
        eprintln!();
        eprintln!("  {} {}", "üí°".green(), "Suggestion:".green().bold());
        eprintln!("     {}", suggestion.bright_white());
    }

    eprintln!();
    eprintln!("{}", "‚îÅ".repeat(70).red());
    eprintln!();
}

/// Print success message
#[allow(dead_code)]
pub fn print_success(message: &str) {
    eprintln!("{} {}", "‚úì".green().bold(), message.bright_white());
}

/// Print warning message
#[allow(dead_code)]
pub fn print_warning(message: &str) {
    eprintln!("{} {}", "‚ö†".yellow().bold(), message.yellow());
}

/// Print info message
#[allow(dead_code)]
pub fn print_info(message: &str) {
    eprintln!("{} {}", "‚Ñπ".blue().bold(), message.bright_white());
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::io;

    #[test]
    fn test_error_suggestion_file_not_found() {
        let err = CliError::FileNotFound(PathBuf::from("test.json"));
        assert!(err.suggestion().is_some());
        assert!(err.suggestion().unwrap().contains("borrowscope run"));
    }

    #[test]
    fn test_error_suggestion_port_in_use_low() {
        let err = CliError::PortInUse(3000);
        assert!(err.suggestion().is_some());
        assert!(err.suggestion().unwrap().contains("higher port"));
    }

    #[test]
    fn test_error_suggestion_port_in_use_high() {
        let err = CliError::PortInUse(9000);
        assert!(err.suggestion().is_some());
        assert!(err.suggestion().unwrap().contains("different port"));
    }

    #[test]
    fn test_error_suggestion_cargo_not_found() {
        let err = CliError::CommandNotFound("cargo".to_string());
        assert!(err.suggestion().is_some());
        assert!(err.suggestion().unwrap().contains("rustup.rs"));
    }

    #[test]
    fn test_error_suggestion_graphviz_not_found() {
        let err = CliError::CommandNotFound("dot".to_string());
        assert!(err.suggestion().is_some());
        assert!(err.suggestion().unwrap().contains("Graphviz"));
    }

    #[test]
    fn test_error_suggestion_invalid_format() {
        let err = CliError::InvalidFormat("corrupted data".to_string());
        assert!(err.suggestion().is_some());
        assert!(err.suggestion().unwrap().contains("valid JSON"));
    }

    #[test]
    fn test_error_suggestion_config_error() {
        let err = CliError::ConfigError("missing field".to_string());
        assert!(err.suggestion().is_some());
        assert!(err.suggestion().unwrap().contains("borrowscope init"));
    }

    #[test]
    fn test_error_suggestion_build_error() {
        let err = CliError::BuildError("compilation failed".to_string());
        assert!(err.suggestion().is_some());
        assert!(err.suggestion().unwrap().contains("Cargo.toml"));
    }

    #[test]
    fn test_error_suggestion_instrumentation_error() {
        let err = CliError::InstrumentationError("parse error".to_string());
        assert!(err.suggestion().is_some());
        assert!(err.suggestion().unwrap().contains("syntactically correct"));
    }

    #[test]
    fn test_error_suggestion_none_for_other() {
        let err = CliError::Other("unknown error".to_string());
        assert!(err.suggestion().is_none());
    }

    #[test]
    fn test_error_category_file_not_found() {
        let err = CliError::FileNotFound(PathBuf::from("test.json"));
        assert_eq!(err.category(), "File Error");
    }

    #[test]
    fn test_error_category_config() {
        let err = CliError::ConfigError("test".to_string());
        assert_eq!(err.category(), "Configuration Error");
    }

    #[test]
    fn test_error_category_port_in_use() {
        let err = CliError::PortInUse(3000);
        assert_eq!(err.category(), "Network Error");
    }

    #[test]
    fn test_error_category_build() {
        let err = CliError::BuildError("test".to_string());
        assert_eq!(err.category(), "Build Error");
    }

    #[test]
    fn test_error_category_validation() {
        let err = CliError::ValidationError("test".to_string());
        assert_eq!(err.category(), "Validation Error");
    }

    #[test]
    fn test_error_from_io() {
        let io_err = io::Error::new(io::ErrorKind::NotFound, "file not found");
        let cli_err: CliError = io_err.into();
        assert!(matches!(cli_err, CliError::Io(_)));
    }

    #[test]
    fn test_error_from_json() {
        let json_err = serde_json::from_str::<serde_json::Value>("invalid").unwrap_err();
        let cli_err: CliError = json_err.into();
        assert!(matches!(cli_err, CliError::Json(_)));
    }

    #[test]
    fn test_error_from_toml() {
        let toml_err = toml::from_str::<toml::Value>("invalid = ").unwrap_err();
        let cli_err: CliError = toml_err.into();
        assert!(matches!(cli_err, CliError::Toml(_)));
    }

    #[test]
    fn test_error_display_file_not_found() {
        let err = CliError::FileNotFound(PathBuf::from("/path/to/file.json"));
        let display = format!("{}", err);
        assert!(display.contains("File not found"));
        assert!(display.contains("/path/to/file.json"));
    }

    #[test]
    fn test_error_display_port_in_use() {
        let err = CliError::PortInUse(8080);
        let display = format!("{}", err);
        assert!(display.contains("Port 8080"));
        assert!(display.contains("already in use"));
    }

    #[test]
    fn test_error_chain_io_error() {
        let io_err = io::Error::new(io::ErrorKind::PermissionDenied, "access denied");
        let cli_err: CliError = io_err.into();

        assert!(cli_err.source().is_some());
        let source = cli_err.source().unwrap();
        assert!(source.to_string().contains("access denied"));
    }

    #[test]
    fn test_error_debug_format() {
        let err = CliError::Other("test error".to_string());
        let debug = format!("{:?}", err);
        assert!(debug.contains("Other"));
        assert!(debug.contains("test error"));
    }

    #[test]
    fn test_multiple_error_variants() {
        let errors = vec![
            CliError::FileNotFound(PathBuf::from("test.json")),
            CliError::InvalidFormat("bad format".to_string()),
            CliError::ConfigError("bad config".to_string()),
            CliError::ExecutionFailed("exec failed".to_string()),
            CliError::Graph("graph error".to_string()),
            CliError::PortInUse(3000),
            CliError::CommandNotFound("cmd".to_string()),
            CliError::InstrumentationError("inst error".to_string()),
            CliError::BuildError("build error".to_string()),
            CliError::ValidationError("val error".to_string()),
            CliError::Other("other error".to_string()),
        ];

        for err in errors {
            // All errors should have a category
            assert!(!err.category().is_empty());
            // All errors should display properly
            assert!(!err.to_string().is_empty());
        }
    }

    #[test]
    fn test_result_type_alias() {
        fn returns_result() -> Result<i32> {
            Ok(42)
        }

        fn returns_error() -> Result<i32> {
            Err(CliError::Other("test".to_string()))
        }

        assert!(returns_result().is_ok());
        assert!(returns_error().is_err());
    }

    #[test]
    fn test_error_suggestion_command_not_found_other() {
        let err = CliError::CommandNotFound("unknown".to_string());
        assert!(err.suggestion().is_none());
    }

    #[test]
    fn test_error_category_all_variants() {
        let categories = vec![
            (CliError::FileNotFound(PathBuf::from("test")), "File Error"),
            (CliError::InvalidFormat("test".to_string()), "Format Error"),
            (
                CliError::ConfigError("test".to_string()),
                "Configuration Error",
            ),
            (
                CliError::ExecutionFailed("test".to_string()),
                "Execution Error",
            ),
            (CliError::Graph("test".to_string()), "Graph Error"),
            (CliError::PortInUse(3000), "Network Error"),
            (
                CliError::CommandNotFound("test".to_string()),
                "Command Error",
            ),
            (
                CliError::InstrumentationError("test".to_string()),
                "Instrumentation Error",
            ),
            (CliError::BuildError("test".to_string()), "Build Error"),
            (
                CliError::ValidationError("test".to_string()),
                "Validation Error",
            ),
            (CliError::Other("test".to_string()), "Error"),
        ];

        for (err, expected_category) in categories {
            assert_eq!(err.category(), expected_category);
        }
    }

    #[test]
    fn test_print_functions_dont_panic() {
        let err = CliError::Other("test".to_string());
        print_error(&err);
        print_success("test");
        print_warning("test");
        print_info("test");
    }
}
