# Section 17: Code Generation with quote

## Learning Objectives

By the end of this section, you will:
- Master advanced quote! patterns
- Generate clean, readable code
- Optimize generated code
- Handle code formatting
- Use quote! effectively for complex scenarios

## Prerequisites

- Completed Section 16
- Understanding of quote! basics
- Familiarity with TokenStream

---

## Advanced quote! Patterns

### Pattern 1: Conditional Generation

```rust
use quote::quote;

let include_debug = true;
let code = quote! {
    fn example() {
        println!("Always included");
        
        #(
            if #include_debug {
                println!("Debug mode");
            }
        )*
    }
};
```

### Pattern 2: Optional Code

```rust
let maybe_code = if condition {
    Some(quote! { println!("Optional"); })
} else {
    None
};

let code = quote! {
    fn example() {
        #maybe_code
    }
};
```

### Pattern 3: Repetition with Separator

```rust
let items = vec!["a", "b", "c"];

// Comma-separated
let code = quote! { (#(#items),*) };
// Output: (a, b, c)

// Semicolon-separated
let code = quote! { #(#items;)* };
// Output: a; b; c;

// No separator
let code = quote! { #(#items)* };
// Output: abc
```

---

## Optimizing Generated Code

### File: `borrowscope-macro/src/codegen.rs`

```rust
//! Code generation utilities

use quote::quote;
use syn::{Ident, Expr};

/// Generate optimized tracking call
pub fn generate_track_new(var_name: &Ident, init_expr: &Expr) -> proc_macro2::TokenStream {
    quote! {
        borrowscope_runtime::track_new(stringify!(#var_name), #init_expr)
    }
}

/// Generate optimized borrow tracking
pub fn generate_track_borrow(
    var_name: &Ident,
    borrowed_expr: &Expr,
    is_mutable: bool,
) -> proc_macro2::TokenStream {
    if is_mutable {
        quote! {
            borrowscope_runtime::track_borrow_mut(stringify!(#var_name), #borrowed_expr)
        }
    } else {
        quote! {
            borrowscope_runtime::track_borrow(stringify!(#var_name), #borrowed_expr)
        }
    }
}

/// Generate drop calls with proper ordering
pub fn generate_drop_calls(variables: &[Ident]) -> proc_macro2::TokenStream {
    // Reverse order (LIFO)
    let reversed: Vec<_> = variables.iter().rev().collect();
    
    quote! {
        #(
            borrowscope_runtime::track_drop(stringify!(#reversed));
        )*
    }
}

/// Generate function wrapper with tracking
pub fn generate_tracked_function(
    func: &syn::ItemFn,
    tracked_vars: &[Ident],
) -> proc_macro2::TokenStream {
    let attrs = &func.attrs;
    let vis = &func.vis;
    let sig = &func.sig;
    let block = &func.block;
    
    let drop_calls = generate_drop_calls(tracked_vars);
    
    quote! {
        #(#attrs)*
        #vis #sig {
            #block
            #drop_calls
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use syn::parse_quote;

    #[test]
    fn test_generate_track_new() {
        let var: Ident = parse_quote!(x);
        let expr: Expr = parse_quote!(5);
        
        let code = generate_track_new(&var, &expr);
        let result = code.to_string();
        
        assert!(result.contains("track_new"));
        assert!(result.contains("stringify"));
    }

    #[test]
    fn test_generate_drop_calls() {
        let vars = vec![
            parse_quote!(x),
            parse_quote!(y),
            parse_quote!(z),
        ];
        
        let code = generate_drop_calls(&vars);
        let result = code.to_string();
        
        // Should be in reverse order
        let z_pos = result.find('z').unwrap();
        let y_pos = result.find('y').unwrap();
        let x_pos = result.find('x').unwrap();
        
        assert!(z_pos < y_pos);
        assert!(y_pos < x_pos);
    }
}
```

---

## Clean Code Generation

### File: `borrowscope-macro/src/formatting.rs`

```rust
//! Code formatting utilities

use proc_macro2::TokenStream;
use quote::quote;

/// Format generated code for readability
pub fn format_code(tokens: TokenStream) -> TokenStream {
    // Parse and re-format
    match syn::parse2::<syn::File>(tokens.clone()) {
        Ok(file) => {
            // Use prettyplease for formatting
            let formatted = prettyplease::unparse(&file);
            formatted.parse().unwrap_or(tokens)
        }
        Err(_) => tokens,
    }
}

/// Add comments to generated code
pub fn add_tracking_comment(code: TokenStream) -> TokenStream {
    quote! {
        // Generated by BorrowScope
        #code
    }
}

/// Generate with proper indentation
pub fn generate_indented_block(stmts: &[syn::Stmt]) -> TokenStream {
    quote! {
        {
            #(#stmts)*
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use syn::parse_quote;

    #[test]
    fn test_generate_indented_block() {
        let stmts: Vec<syn::Stmt> = vec![
            parse_quote! { let x = 5; },
            parse_quote! { let y = 10; },
        ];
        
        let code = generate_indented_block(&stmts);
        let result = code.to_string();
        
        assert!(result.contains('{'));
        assert!(result.contains('}'));
    }
}
```

---

## Span Preservation

### File: `borrowscope-macro/src/span_utils.rs`

```rust
//! Span utilities for better error messages

use proc_macro2::Span;
use quote::quote_spanned;
use syn::{Expr, Ident};

/// Generate code with preserved span
pub fn generate_with_span(
    span: Span,
    var_name: &Ident,
    expr: &Expr,
) -> proc_macro2::TokenStream {
    quote_spanned! { span =>
        borrowscope_runtime::track_new(stringify!(#var_name), #expr)
    }
}

/// Create identifier with specific span
pub fn ident_with_span(name: &str, span: Span) -> Ident {
    Ident::new(name, span)
}

/// Get span from expression
pub fn expr_span(expr: &Expr) -> Span {
    match expr {
        Expr::Path(path) => path.path.segments.first()
            .map(|seg| seg.ident.span())
            .unwrap_or_else(Span::call_site),
        Expr::Lit(lit) => lit.lit.span(),
        _ => expr.span(),
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use syn::parse_quote;

    #[test]
    fn test_ident_with_span() {
        let span = Span::call_site();
        let ident = ident_with_span("test", span);
        assert_eq!(ident.to_string(), "test");
    }

    #[test]
    fn test_expr_span() {
        let expr: Expr = parse_quote!(x);
        let _span = expr_span(&expr);
        // Just verify it doesn't panic
    }
}
```

---

## Complete Example: Optimized Generation

### File: `borrowscope-macro/src/optimized_transform.rs`

```rust
//! Optimized code transformation

use quote::quote;
use syn::{ItemFn, Local, Expr, Ident};
use crate::codegen::*;
use crate::pattern::PatternInfo;

/// Transform function with optimizations
pub fn transform_function_optimized(
    func: &ItemFn,
    tracked_vars: &[Ident],
) -> proc_macro2::TokenStream {
    let attrs = &func.attrs;
    let vis = &func.vis;
    let sig = &func.sig;
    let stmts = &func.block.stmts;
    
    // Generate drop calls
    let drop_calls = generate_drop_calls(tracked_vars);
    
    // Generate optimized function
    quote! {
        #(#attrs)*
        #vis #sig {
            #(#stmts)*
            
            // Cleanup tracking
            #drop_calls
        }
    }
}

/// Transform let statement with optimization
pub fn transform_let_optimized(local: &Local) -> Option<proc_macro2::TokenStream> {
    let pattern_info = PatternInfo::analyze(&local.pat);
    
    if !pattern_info.is_trackable() {
        return None;
    }
    
    if !pattern_info.is_simple {
        return None; // Complex patterns handled elsewhere
    }
    
    let var_name = &pattern_info.variables[0];
    let init = local.init.as_ref()?;
    let init_expr = &init.expr;
    
    // Check for borrow
    if let Expr::Reference(reference) = init_expr.as_ref() {
        let is_mutable = reference.mutability.is_some();
        let borrowed_expr = &reference.expr;
        
        Some(generate_track_borrow(var_name, borrowed_expr, is_mutable))
    } else {
        Some(generate_track_new(var_name, init_expr))
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use syn::parse_quote;

    #[test]
    fn test_transform_let_optimized() {
        let local: Local = parse_quote! { let x = 5; };
        let result = transform_let_optimized(&local);
        
        assert!(result.is_some());
        let code = result.unwrap();
        assert!(code.to_string().contains("track_new"));
    }
}
```

---

## Key Takeaways

✅ **Clean generation** - Readable, maintainable code  
✅ **Optimization** - Minimal overhead  
✅ **Span preservation** - Better error messages  
✅ **Formatting** - Proper indentation  
✅ **Reusable utilities** - DRY principle  

---

**Previous:** [16-identifying-borrow-expressions.md](./16-identifying-borrow-expressions.md)  
**Next:** [18-macro-hygiene-and-best-practices.md](./18-macro-hygiene-and-best-practices.md)

**Progress:** 9/12 ⬛⬛⬛⬛⬛⬛⬛⬛⬛⬜⬜⬜
