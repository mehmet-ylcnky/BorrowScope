# Section 4: Git and Version Control Setup

## Learning Objectives

By the end of this section, you will:
- Understand Git best practices for Rust projects
- Configure Git properly for the BorrowScope workspace
- Learn effective commit message conventions
- Set up branch strategies for development
- Understand what to track and what to ignore
- Be ready to collaborate and track changes effectively

## Prerequisites

- Completed Section 3 (workspace created)
- Git installed on your system
- Basic Git knowledge (commit, push, pull)
- GitHub account (optional, for remote repository)

---

## Why Version Control Matters

### The Problem Without Git

Imagine developing BorrowScope without version control:

```
borrowscope/
├── borrowscope-old/
├── borrowscope-backup/
├── borrowscope-working/
├── borrowscope-before-refactor/
└── borrowscope-final-really-this-time/
```

**Issues:**
- Can't track what changed and why
- Can't revert mistakes
- Can't collaborate effectively
- Can't experiment safely
- No history of decisions

### The Solution: Git

With Git, you have:
- ✅ Complete history of every change
- ✅ Ability to revert to any point
- ✅ Safe experimentation with branches
- ✅ Collaboration through pull requests
- ✅ Documentation through commit messages

---

## Step 1: Initialize Git Repository

If you haven't already:

```bash
cd borrowscope
git init
```

Output:
```
Initialized empty Git repository in /path/to/borrowscope/.git/
```

### Configure Git Identity

Set your name and email (if not already configured globally):

```bash
git config user.name "Your Name"
git config user.email "your.email@example.com"
```

**Check your configuration:**
```bash
git config --list | grep user
```

---

## Step 2: Create a Comprehensive .gitignore

We created a basic `.gitignore` in Section 3. Let's make it comprehensive:

```bash
cat > .gitignore << 'EOF'
# Rust Build Artifacts
/target/
**/target/
**/*.rs.bk
*.pdb

# Cargo Lock
# Uncomment if this is a library (we keep it for applications)
# Cargo.lock

# Debug and Release Builds
debug/
release/

# Rust Analyzer
.rust-analyzer/

# IDE - Visual Studio Code
.vscode/
*.code-workspace

# IDE - IntelliJ IDEA / RustRover
.idea/
*.iml
*.ipr
*.iws
out/

# IDE - Vim
*.swp
*.swo
*~
.*.sw?

# IDE - Emacs
*~
\#*\#
.\#*

# Operating System
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db
Desktop.ini

# BorrowScope Specific
borrowscope-output/
*.borrowscope.json
borrowscope-temp/

# Test Artifacts
*.profraw
*.profdata

# Documentation Build
/book/
/target/doc/

# Temporary Files
*.tmp
*.temp
*.log

# Environment Variables
.env
.env.local

# Coverage Reports
coverage/
*.lcov
tarpaulin-report.html

# Benchmark Results
criterion/
benches/target/

# Node.js (for UI later)
node_modules/
dist/
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# macOS
.AppleDouble
.LSOverride

# Linux
.directory
.Trash-*

# Windows
$RECYCLE.BIN/
*.lnk
EOF
```

### Understanding .gitignore Patterns

**`/target/`** - Ignore the target directory at root
```
borrowscope/target/  ✅ Ignored
borrowscope/foo/target/  ❌ Not ignored
```

**`**/target/`** - Ignore target directories anywhere
```
borrowscope/target/  ✅ Ignored
borrowscope/foo/target/  ✅ Ignored
borrowscope/foo/bar/target/  ✅ Ignored
```

**`*.rs.bk`** - Ignore all .rs.bk files (Rust backup files)

**`*.log`** - Ignore all log files

### Why Ignore These Files?

**Build artifacts (`target/`):**
- Generated by Cargo
- Large (hundreds of MB)
- Can be rebuilt anytime
- Different per machine

**IDE files (`.vscode/`, `.idea/`):**
- Personal preferences
- Different per developer
- Not part of the project

**OS files (`.DS_Store`, `Thumbs.db`):**
- Operating system metadata
- Not relevant to the project
- Pollute the repository

**Cargo.lock:**
- **Keep for applications** (like BorrowScope)
- Ignore for libraries
- Ensures reproducible builds

---

## Step 3: Create .gitattributes

This file tells Git how to handle different file types:

```bash
cat > .gitattributes << 'EOF'
# Auto detect text files and perform LF normalization
* text=auto

# Rust source files
*.rs text eol=lf
*.toml text eol=lf

# Documentation
*.md text eol=lf
*.txt text eol=lf

# Scripts
*.sh text eol=lf
*.bash text eol=lf

# Windows scripts
*.bat text eol=crlf
*.cmd text eol=crlf
*.ps1 text eol=crlf

# JSON, YAML, XML
*.json text eol=lf
*.yaml text eol=lf
*.yml text eol=lf
*.xml text eol=lf

# Binary files
*.png binary
*.jpg binary
*.jpeg binary
*.gif binary
*.ico binary
*.woff binary
*.woff2 binary
*.ttf binary
*.eot binary

# Archives
*.zip binary
*.tar binary
*.gz binary
*.7z binary

# Linguist (GitHub language detection)
*.rs linguist-language=Rust
docs/* linguist-documentation
examples/* linguist-documentation
EOF
```

### Why .gitattributes?

**Line endings:**
- Unix/Linux/macOS use LF (`\n`)
- Windows uses CRLF (`\r\n`)
- `text eol=lf` ensures consistent line endings

**Binary files:**
- Prevents Git from trying to merge them
- Avoids corruption

**Language detection:**
- Helps GitHub correctly identify the project language
- Excludes documentation from statistics

---

## Step 4: Initial Commit

### Check Status

```bash
git status
```

You should see:
```
On branch main

No commits yet

Untracked files:
  .gitattributes
  .gitignore
  Cargo.toml
  LICENSE-APACHE
  LICENSE-MIT
  README.md
  borrowscope-cli/
  borrowscope-macro/
  borrowscope-runtime/
```

### Stage All Files

```bash
git add .
```

### Review What Will Be Committed

```bash
git status
```

Output:
```
On branch main

No commits yet

Changes to be committed:
  new file:   .gitattributes
  new file:   .gitignore
  new file:   Cargo.toml
  new file:   LICENSE-APACHE
  new file:   LICENSE-MIT
  new file:   README.md
  new file:   borrowscope-cli/Cargo.toml
  new file:   borrowscope-cli/src/main.rs
  new file:   borrowscope-macro/Cargo.toml
  new file:   borrowscope-macro/src/lib.rs
  new file:   borrowscope-runtime/Cargo.toml
  new file:   borrowscope-runtime/src/lib.rs
```

### Make the Initial Commit

```bash
git commit -m "Initial commit: BorrowScope workspace setup

- Created Cargo workspace with three crates
- borrowscope-macro: Procedural macro crate (stub)
- borrowscope-runtime: Event tracking library (stub)
- borrowscope-cli: Command-line interface (stub)
- Added licenses (MIT/Apache-2.0)
- Configured .gitignore and .gitattributes
- All crates compile successfully"
```

---

## Step 5: Commit Message Conventions

### The Anatomy of a Good Commit Message

```
<type>(<scope>): <subject>

<body>

<footer>
```

### Example: Good Commit Message

```
feat(runtime): implement basic event tracking

- Add Event enum with New, Borrow, Move, Drop variants
- Implement track_new() with timestamp generation
- Add global Tracker with Mutex for thread safety
- Include unit tests for basic tracking

Closes #12
```

### Commit Types

**feat:** New feature
```
feat(cli): add visualize subcommand
```

**fix:** Bug fix
```
fix(macro): handle nested borrow expressions correctly
```

**docs:** Documentation changes
```
docs(readme): add installation instructions
```

**test:** Adding or updating tests
```
test(runtime): add property-based tests for tracking
```

**refactor:** Code refactoring
```
refactor(macro): extract AST visitor into separate module
```

**perf:** Performance improvements
```
perf(runtime): use lock-free queue for event collection
```

**chore:** Maintenance tasks
```
chore: update dependencies to latest versions
```

**ci:** CI/CD changes
```
ci: add GitHub Actions workflow for testing
```

### Scope Examples

- `(macro)` - Changes to borrowscope-macro
- `(runtime)` - Changes to borrowscope-runtime
- `(cli)` - Changes to borrowscope-cli
- `(ui)` - Changes to borrowscope-ui
- `(workspace)` - Changes affecting the whole workspace
- `(deps)` - Dependency updates

### Subject Line Rules

✅ **Do:**
- Use imperative mood ("add" not "added")
- Keep under 50 characters
- Don't end with a period
- Be specific and clear

❌ **Don't:**
- "Fixed stuff"
- "WIP"
- "asdf"
- "Updated files"

### Body Guidelines

- Wrap at 72 characters
- Explain **what** and **why**, not **how**
- Use bullet points for multiple changes
- Reference issues/PRs

### Footer

- `Closes #123` - Closes an issue
- `Fixes #456` - Fixes a bug
- `Refs #789` - References an issue
- `Breaking Change:` - Indicates breaking changes

---

## Step 6: Branch Strategy

### Main Branch

```bash
# Ensure you're on main
git branch -M main
```

**Purpose:** Stable, working code. Always compiles and passes tests.

### Development Workflow

#### Feature Branches

For new features:
```bash
git checkout -b feat/event-tracking
# Work on feature
git commit -m "feat(runtime): implement event tracking"
git checkout main
git merge feat/event-tracking
```

#### Bug Fix Branches

For bug fixes:
```bash
git checkout -b fix/macro-hygiene
# Fix the bug
git commit -m "fix(macro): resolve hygiene issue with generated code"
git checkout main
git merge fix/macro-hygiene
```

#### Refactoring Branches

For refactoring:
```bash
git checkout -b refactor/ast-visitor
# Refactor code
git commit -m "refactor(macro): extract visitor pattern"
git checkout main
git merge refactor/ast-visitor
```

### Branch Naming Convention

```
<type>/<short-description>
```

**Examples:**
- `feat/websocket-streaming`
- `fix/borrow-tracking-bug`
- `docs/api-documentation`
- `test/integration-tests`
- `refactor/graph-builder`

---

## Step 7: Useful Git Aliases

Add these to your Git config for productivity:

```bash
# Short status
git config --global alias.st status

# Short log
git config --global alias.lg "log --oneline --graph --decorate --all"

# Amend last commit
git config --global alias.amend "commit --amend --no-edit"

# Show diff of staged changes
git config --global alias.staged "diff --staged"

# Undo last commit (keep changes)
git config --global alias.undo "reset HEAD~1 --soft"

# Clean up merged branches
git config --global alias.cleanup "!git branch --merged | grep -v '\\*\\|main\\|master' | xargs -n 1 git branch -d"
```

**Usage:**
```bash
git st              # Instead of git status
git lg              # Pretty log
git amend           # Amend last commit
git staged          # See what's staged
git undo            # Undo last commit
git cleanup         # Remove merged branches
```

---

## Step 8: Create a .gitkeep for Empty Directories

Git doesn't track empty directories. If you need to preserve structure:

```bash
# Create directories for future use
mkdir -p borrowscope-runtime/benches
mkdir -p borrowscope-cli/tests
mkdir -p docs

# Add .gitkeep files
touch borrowscope-runtime/benches/.gitkeep
touch borrowscope-cli/tests/.gitkeep
touch docs/.gitkeep

# Commit
git add .
git commit -m "chore: add directory structure for tests and docs"
```

---

## Step 9: Set Up Remote Repository (Optional)

### Create GitHub Repository

1. Go to https://github.com/new
2. Name: `borrowscope`
3. Description: "Visualize Rust ownership and borrowing"
4. Public or Private
5. **Don't** initialize with README (we already have one)
6. Click "Create repository"

### Add Remote

```bash
git remote add origin https://github.com/yourusername/borrowscope.git
```

### Push to GitHub

```bash
git push -u origin main
```

### Verify

```bash
git remote -v
```

Output:
```
origin  https://github.com/yourusername/borrowscope.git (fetch)
origin  https://github.com/yourusername/borrowscope.git (push)
```

---

## Step 10: Create a CONTRIBUTING.md

```bash
cat > CONTRIBUTING.md << 'EOF'
# Contributing to BorrowScope

Thank you for your interest in contributing!

## Development Setup

1. Clone the repository:
   ```bash
   git clone https://github.com/yourusername/borrowscope.git
   cd borrowscope
   ```

2. Build the project:
   ```bash
   cargo build --workspace
   ```

3. Run tests:
   ```bash
   cargo test --workspace
   ```

## Commit Message Convention

We follow the Conventional Commits specification:

```
<type>(<scope>): <subject>

<body>

<footer>
```

**Types:** feat, fix, docs, test, refactor, perf, chore, ci

**Example:**
```
feat(runtime): add event streaming support

- Implement WebSocket server
- Add real-time event broadcasting
- Include integration tests

Closes #42
```

## Branch Naming

- `feat/feature-name` - New features
- `fix/bug-description` - Bug fixes
- `docs/what-changed` - Documentation
- `test/test-description` - Tests
- `refactor/what-refactored` - Refactoring

## Pull Request Process

1. Create a feature branch
2. Make your changes
3. Add tests
4. Ensure all tests pass
5. Update documentation
6. Submit a pull request

## Code Style

- Run `cargo fmt` before committing
- Run `cargo clippy` and fix warnings
- Write doc comments for public APIs
- Add tests for new functionality

## Questions?

Open an issue or start a discussion!
EOF
```

Commit it:
```bash
git add CONTRIBUTING.md
git commit -m "docs: add contributing guidelines"
```

---

## Best Practices Summary

### What to Commit

✅ **Do commit:**
- Source code (`.rs` files)
- Configuration files (`Cargo.toml`, `.toml`)
- Documentation (`.md` files)
- Tests
- Scripts
- `Cargo.lock` (for applications)
- Licenses

❌ **Don't commit:**
- Build artifacts (`target/`)
- IDE settings (`.vscode/`, `.idea/`)
- OS files (`.DS_Store`)
- Temporary files
- Secrets or credentials
- Large binary files (unless necessary)

### Commit Frequency

**Commit often:**
- After completing a logical unit of work
- Before switching tasks
- Before risky refactoring
- At the end of each day

**Each commit should:**
- Compile successfully
- Pass all tests
- Be atomic (one logical change)
- Have a clear message

### Branch Strategy

**For solo development:**
- Work on `main` for small changes
- Use feature branches for larger work
- Merge when feature is complete

**For team development:**
- Never commit directly to `main`
- Always use feature branches
- Use pull requests for review
- Require tests and CI to pass

---

## Common Git Workflows

### Workflow 1: Simple Feature

```bash
# Start new feature
git checkout -b feat/new-feature

# Make changes
# ... edit files ...

# Stage and commit
git add .
git commit -m "feat: implement new feature"

# Switch back to main
git checkout main

# Merge feature
git merge feat/new-feature

# Delete feature branch
git branch -d feat/new-feature
```

### Workflow 2: Fix a Bug

```bash
# Create fix branch
git checkout -b fix/bug-description

# Fix the bug
# ... edit files ...

# Test the fix
cargo test

# Commit
git add .
git commit -m "fix: resolve bug description

- Explain what was wrong
- Explain how it's fixed
- Add regression test

Fixes #123"

# Merge
git checkout main
git merge fix/bug-description
git branch -d fix/bug-description
```

### Workflow 3: Experiment Safely

```bash
# Create experimental branch
git checkout -b experiment/new-approach

# Try something risky
# ... make changes ...

# If it works:
git checkout main
git merge experiment/new-approach

# If it doesn't work:
git checkout main
git branch -D experiment/new-approach  # Force delete
```

---

## Useful Git Commands

### Viewing History

```bash
# Show commit history
git log

# Pretty log
git log --oneline --graph --decorate

# Show changes in last commit
git show

# Show changes in specific commit
git show abc123

# Search commits
git log --grep="feature"
```

### Undoing Changes

```bash
# Discard changes in working directory
git checkout -- file.rs

# Unstage file
git reset HEAD file.rs

# Undo last commit (keep changes)
git reset --soft HEAD~1

# Undo last commit (discard changes)
git reset --hard HEAD~1

# Revert a commit (creates new commit)
git revert abc123
```

### Stashing

```bash
# Save work in progress
git stash

# List stashes
git stash list

# Apply most recent stash
git stash pop

# Apply specific stash
git stash apply stash@{0}
```

### Branching

```bash
# List branches
git branch

# Create branch
git branch feature-name

# Switch branch
git checkout feature-name

# Create and switch
git checkout -b feature-name

# Delete branch
git branch -d feature-name

# Force delete
git branch -D feature-name
```

---

## Exercises

### Exercise 1: Practice Commits

Make three separate commits:

1. Add a comment to `borrowscope-runtime/src/lib.rs`
2. Update the README with a new section
3. Add a test to any crate

Use proper commit messages for each.

### Exercise 2: Branch Workflow

1. Create a feature branch
2. Make a change
3. Commit the change
4. Switch back to main
5. Merge the feature branch
6. Delete the feature branch

### Exercise 3: View History

```bash
# View your commit history
git log --oneline

# View changes in last commit
git show

# View all branches
git branch -a
```

---

## Troubleshooting

### Problem: Committed Wrong Files

```bash
# Remove file from staging
git reset HEAD unwanted-file.txt

# Amend last commit
git add correct-file.txt
git commit --amend
```

### Problem: Wrong Commit Message

```bash
# Change last commit message
git commit --amend -m "New message"
```

### Problem: Need to Undo Last Commit

```bash
# Keep changes, undo commit
git reset --soft HEAD~1

# Discard changes and commit
git reset --hard HEAD~1
```

### Problem: Merge Conflict

```bash
# See conflicted files
git status

# Edit files to resolve conflicts
# Look for <<<<<<< and >>>>>>>

# Mark as resolved
git add resolved-file.rs

# Complete merge
git commit
```

---

## Key Takeaways

### Git Fundamentals

✅ `.gitignore` prevents tracking unwanted files  
✅ `.gitattributes` ensures consistent file handling  
✅ Commit messages document **why** changes were made  
✅ Branches enable safe experimentation  
✅ Frequent commits create detailed history  

### Best Practices

✅ Commit early, commit often  
✅ Write clear, descriptive commit messages  
✅ Use branches for features and fixes  
✅ Keep commits atomic and focused  
✅ Test before committing  

### BorrowScope Specific

✅ Keep `Cargo.lock` (it's an application)  
✅ Ignore `target/` and IDE files  
✅ Use conventional commit format  
✅ Branch naming: `type/description`  
✅ Document in CONTRIBUTING.md  

---

## Further Reading

### Official Documentation

1. **Pro Git Book**
   - https://git-scm.com/book/en/v2

2. **Conventional Commits**
   - https://www.conventionalcommits.org/

3. **GitHub Flow**
   - https://guides.github.com/introduction/flow/

### Rust-Specific

1. **Rust .gitignore Template**
   - https://github.com/github/gitignore/blob/main/Rust.gitignore

2. **Cargo Book - Publishing**
   - https://doc.rust-lang.org/cargo/reference/publishing.html

---

## Reflection Questions

Before moving to Section 5, ensure you can answer:

✅ What files should be ignored in a Rust project?  
✅ What makes a good commit message?  
✅ When should you create a new branch?  
✅ How do you undo the last commit?  
✅ Why keep Cargo.lock for applications?  

---

## What's Next?

In **Section 5: CI/CD Pipeline Basics**, we'll:
- Set up GitHub Actions for automated testing
- Configure cross-platform builds
- Add code quality checks
- Automate the development workflow

---

**Previous Section:** [03-setting-up-the-workspace.md](./03-setting-up-the-workspace.md)  
**Next Section:** [05-ci-cd-pipeline-basics.md](./05-ci-cd-pipeline-basics.md)

**Chapter Progress:** 4/8 sections complete ⬛⬛⬛⬜⬜⬜⬜

---

*"Good version control is like a time machine for your code." ⏰*
