# Section 62: Macro-Generated Code

## Learning Objectives

By the end of this section, you will:
- Handle code generated by other macros
- Understand macro expansion order
- Deal with macro hygiene
- Track through macro boundaries
- Recognize limitations

## Prerequisites

- Completed Section 61 (Unsafe Tracking)
- Understanding of Rust macros
- Familiarity with macro expansion

---

## Macro Expansion Order

```rust
#[track_ownership]
fn example() {
    let x = vec![1, 2, 3];  // vec! macro expands first
}
```

**Expansion order:**
1. `vec!` expands to `Vec::from([1, 2, 3])`
2. `#[track_ownership]` sees the expanded code

---

## Common Macros

### vec!

```rust
let v = vec![1, 2, 3];

// Expands to:
let v = <[_]>::into_vec(box [1, 2, 3]);
```

**Tracking:** We see the expanded form.

### println!

```rust
println!("Hello, {}", name);

// Expands to:
std::io::_print(std::format_args!("Hello, {}", name));
```

**Tracking:** Track the variables used, not the macro itself.

### format!

```rust
let s = format!("Value: {}", x);

// Expands to:
let s = std::fmt::format(std::format_args!("Value: {}", x));
```

---

## Detection Strategy

**Challenge:** We can't easily detect what was a macro.

**Solution:** Work with the expanded code.

```rust
// User writes:
let v = vec![1, 2, 3];

// We see:
let v = <[_]>::into_vec(box [1, 2, 3]);

// We track:
let v = track_new(1, "v", "Vec<i32>", "line:1:9", <[_]>::into_vec(box [1, 2, 3]));
```

---

## Macro Hygiene

Macros can introduce variables:

```rust
macro_rules! create_var {
    () => {
        let x = 42;
    };
}

#[track_ownership]
fn example() {
    create_var!();  // Creates x
    println!("{}", x);
}
```

**After expansion:**
```rust
fn example() {
    let x = 42;  // From macro
    println!("{}", x);
}
```

**Tracking:** Works normally - we see the expanded code.

---

## Nested Macros

```rust
macro_rules! outer {
    () => {
        inner!();
    };
}

macro_rules! inner {
    () => {
        let x = 42;
    };
}

#[track_ownership]
fn example() {
    outer!();
}
```

**After full expansion:**
```rust
fn example() {
    let x = 42;
}
```

**Tracking:** Works - we see the final expanded code.

---

## Procedural Macros

```rust
#[derive(Debug)]
struct Point {
    x: i32,
    y: i32,
}

#[track_ownership]
fn example() {
    let p = Point { x: 1, y: 2 };
}
```

**Expansion:** `#[derive(Debug)]` generates impl, but doesn't affect our tracking.

---

## Implementation Considerations

```rust
impl OwnershipVisitor {
    fn visit_macro_mut(&mut self, mac: &mut Macro) {
        // We can't easily expand macros ourselves
        // The compiler has already expanded them by the time we see the AST
        
        // Just visit the macro as-is
        visit_mut::visit_macro_mut(self, mac);
    }
}
```

**Key insight:** By the time our proc macro runs, most macros are already expanded.

---

## Testing with Macros

```rust
#[test]
fn test_vec_macro() {
    let mut visitor = OwnershipVisitor::new();
    
    let mut block: syn::Block = parse_quote! {
        {
            let v = vec![1, 2, 3];
        }
    };
    
    visitor.visit_block_mut(&mut block);
    
    let output = block.to_token_stream().to_string();
    
    // vec! is already expanded by the time we see it
    assert!(output.contains("track_new"));
}
```

---

## Special Cases

### assert! and debug_assert!

```rust
assert!(x > 0);

// Expands to:
if !(x > 0) {
    panic!("assertion failed: x > 0");
}
```

**Tracking:** We see the expanded if statement.

### matches!

```rust
let result = matches!(value, Some(x) if x > 0);

// Expands to:
let result = match value {
    Some(x) if x > 0 => true,
    _ => false,
};
```

**Tracking:** We see the match expression.

---

## Custom Macros

Users might define their own macros:

```rust
macro_rules! my_let {
    ($name:ident = $value:expr) => {
        let $name = $value;
    };
}

#[track_ownership]
fn example() {
    my_let!(x = 42);
}
```

**After expansion:**
```rust
fn example() {
    let x = 42;
}
```

**Tracking:** Works automatically.

---

## Limitations

### Can't Track Macro Invocation

```rust
// We can't tell this was originally vec![1, 2, 3]
let v = <[_]>::into_vec(box [1, 2, 3]);
```

**Impact:** Visualization shows expanded code, not original macro.

### Can't Preserve Macro Names

```rust
// User writes:
println!("Hello");

// We track:
std::io::_print(std::format_args!("Hello"));
```

**Impact:** Error messages show expanded code.

---

## Best Practices

### Document Macro Behavior

```rust
/// This function uses vec! macro which expands to Vec::from
#[track_ownership]
fn example() {
    let v = vec![1, 2, 3];
}
```

### Test with Common Macros

```rust
#[test]
fn test_common_macros() {
    // Test vec!
    // Test format!
    // Test println!
    // etc.
}
```

---

## Macro Expansion Debugging

To see expanded code:

```bash
# Expand macros
cargo expand

# Expand specific function
cargo expand example
```

**Use case:** Debug tracking issues with macro-heavy code.

---

## Key Takeaways

✅ **Macros expand before our proc macro** - We see expanded code  
✅ **Hygiene is preserved** - Macro-generated variables tracked normally  
✅ **Nested macros work** - Full expansion happens first  
✅ **Can't preserve macro names** - Show expanded form  
✅ **Test with common macros** - Ensure compatibility  

---

## Further Reading

- [Macros](https://doc.rust-lang.org/book/ch19-06-macros.html)
- [Macro expansion](https://doc.rust-lang.org/reference/macros.html)
- [cargo-expand](https://github.com/dtolnay/cargo-expand)
- [Macro hygiene](https://doc.rust-lang.org/reference/macros-by-example.html#hygiene)

---

**Previous:** [61-unsafe-code-tracking.md](./61-unsafe-code-tracking.md)  
**Next:** [63-performance-considerations.md](./63-performance-considerations.md)

**Progress:** 12/15 ⬛⬛⬛⬛⬛⬛⬛⬛⬛⬛⬛⬛⬜⬜⬜
