# Section 58: Async Rust Fundamentals

## Learning Objectives

By the end of this section, you will:
- Understand async/await syntax and semantics
- Recognize Future trait and polling
- Identify async ownership challenges
- Prepare for async tracking implementation
- Understand async runtime implications

## Prerequisites

- Completed Section 56 (RefCell Tracking)
- Basic understanding of async programming
- Familiarity with futures and executors

---

## Async/Await Basics

```rust
async fn fetch_data() -> String {
    // Async operation
    String::from("data")
}

async fn process() {
    let data = fetch_data().await;
    println!("{}", data);
}
```

**Key insight:** `async fn` returns a `Future`, `.await` polls it.

---

## Future Trait

```rust
pub trait Future {
    type Output;
    
    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output>;
}

pub enum Poll<T> {
    Ready(T),
    Pending,
}
```

**Async functions desugar to:**

```rust
// async fn example() -> i32 { 42 }

// Becomes:
fn example() -> impl Future<Output = i32> {
    async { 42 }
}
```

---

## Ownership in Async

### Challenge 1: Borrows Across Await

```rust
async fn example() {
    let x = String::from("hello");
    let r = &x;
    some_async_fn().await;  // r must be valid here
    println!("{}", r);
}
```

**Compiler ensures:** Borrows are valid across await points.

### Challenge 2: Move into Async Block

```rust
async fn example() {
    let x = String::from("hello");
    
    let future = async move {
        println!("{}", x);  // x moved into async block
    };
    
    future.await;
}
```

---

## Tracking Strategy

For BorrowScope, we need to:

1. **Detect async functions** - Identify `async fn` and `async` blocks
2. **Track across await** - Maintain state across suspension points
3. **Handle futures** - Track Future creation and polling
4. **Async lifetimes** - Track borrows that span await points

---

## Detection

```rust
impl OwnershipVisitor {
    fn is_async_function(&self, func: &ItemFn) -> bool {
        func.sig.asyncness.is_some()
    }
    
    fn detect_async_block(&self, expr: &Expr) -> bool {
        matches!(expr, Expr::Async(_))
    }
    
    fn detect_await(&self, expr: &Expr) -> bool {
        matches!(expr, Expr::Await(_))
    }
}
```

---

## Simplified Tracking Approach

**Challenge:** Async code is complex to track because:
- State machines generated by compiler
- Suspension and resumption
- Multiple execution contexts

**Solution:** Track at the async function boundary:

```rust
#[track_ownership]
async fn example() {
    let x = String::from("hello");
    // Track x creation
    
    some_async_fn().await;
    // x still valid
    
    // Track x drop
}
```

**Limitation:** We don't track across individual await points.

---

## Example Transformation

**Input:**
```rust
#[track_ownership]
async fn fetch() -> String {
    let data = String::from("hello");
    tokio::time::sleep(Duration::from_secs(1)).await;
    data
}
```

**Output:**
```rust
async fn fetch() -> String {
    let data = track_new(1, "data", "String", "line:3:9", String::from("hello"));
    tokio::time::sleep(Duration::from_secs(1)).await;
    track_drop(1, "scope_end");
    data
}
```

**Note:** Tracking works the same, but happens in async context.

---

## Runtime Considerations

### Single-threaded Executor

```rust
#[tokio::main(flavor = "current_thread")]
async fn main() {
    // All tracking happens on one thread
    // No additional synchronization needed
}
```

### Multi-threaded Executor

```rust
#[tokio::main(flavor = "multi_thread")]
async fn main() {
    // Tasks may run on different threads
    // Our Mutex-based tracker handles this
}
```

---

## Testing Async Code

```rust
#[tokio::test]
async fn test_async_tracking() {
    reset_tracker();
    
    let x = track_new(1, "x", "String", "test.rs:1:1", String::from("hello"));
    
    tokio::time::sleep(Duration::from_millis(10)).await;
    
    track_drop(1, "scope_end");
    
    let events = get_events();
    assert_eq!(events.len(), 2);
}
```

---

## Key Takeaways

✅ **Async functions return Futures** - Not executed immediately  
✅ **Await suspends execution** - State preserved across suspension  
✅ **Ownership rules still apply** - Compiler enforces across await  
✅ **Track at function level** - Simplified approach for async  
✅ **Executor agnostic** - Works with tokio, async-std, etc.  

---

## Further Reading

- [Async Book](https://rust-lang.github.io/async-book/)
- [Future trait](https://doc.rust-lang.org/std/future/trait.Future.html)
- [Pin and Unpin](https://doc.rust-lang.org/std/pin/)
- [Tokio tutorial](https://tokio.rs/tokio/tutorial)

---

**Previous:** [57-chapter-summary.md](./57-chapter-summary.md)  
**Next:** [59-trait-objects-and-dynamic-dispatch.md](./59-trait-objects-and-dynamic-dispatch.md)

**Progress:** 8/15 ⬛⬛⬛⬛⬛⬛⬛⬛⬜⬜⬜⬜⬜⬜⬜
