//! Tests for macro-generated code handling
//!
//! These tests verify that the #[trace_borrow] macro works correctly with
//! code generated by other macros, including vec!, format!, println!, assert!,
//! matches!, and custom user-defined macros.

use borrowscope_macro::trace_borrow;
use borrowscope_runtime::*;
use serial_test::serial;

// ============================================================================
// STANDARD LIBRARY MACROS
// ============================================================================

#[test]
#[serial]
fn test_vec_macro() {
    reset();

    #[trace_borrow]
    fn test_fn() {
        let v = vec![1, 2, 3];
        assert_eq!(v.len(), 3);
    }

    test_fn();

    let events = get_events();
    assert!(!events.is_empty());
    // vec! expands to Vec creation which should be tracked
    assert!(events.iter().any(|e| e.is_new()));
}

#[test]
#[serial]
fn test_vec_macro_with_capacity() {
    reset();

    #[trace_borrow]
    fn test_fn() {
        let mut v = Vec::with_capacity(10);
        v.push(1);
        v.push(2);
        assert_eq!(v.len(), 2);
    }

    test_fn();

    let events = get_events();
    assert!(!events.is_empty());
}

#[test]
#[serial]
fn test_vec_macro_repeat() {
    reset();

    #[trace_borrow]
    fn test_fn() {
        let v = vec![0; 5];
        assert_eq!(v.len(), 5);
    }

    test_fn();

    let events = get_events();
    assert!(!events.is_empty());
}

#[test]
#[serial]
fn test_format_macro() {
    reset();

    #[trace_borrow]
    fn test_fn() {
        let name = String::from("Alice");
        let greeting = format!("Hello, {}!", name);
        assert!(greeting.contains("Alice"));
    }

    test_fn();

    let events = get_events();
    assert!(!events.is_empty());
    // Both name and greeting should be tracked
    assert!(events.iter().filter(|e| e.is_new()).count() >= 2);
}

#[test]
#[serial]
fn test_println_macro() {
    reset();

    #[trace_borrow]
    fn test_fn() {
        let x = 42;
        println!("Value: {}", x);
    }

    test_fn();

    let events = get_events();
    assert!(!events.is_empty());
}

#[test]
#[serial]
fn test_assert_macro() {
    reset();

    #[trace_borrow]
    fn test_fn() {
        let x = 42;
        assert!(x > 0);
        assert_eq!(x, 42);
        assert_ne!(x, 0);
    }

    test_fn();

    let events = get_events();
    assert!(!events.is_empty());
}

#[test]
#[serial]
fn test_debug_assert_macro() {
    reset();

    #[trace_borrow]
    fn test_fn() {
        let x = 42;
        debug_assert!(x > 0);
        debug_assert_eq!(x, 42);
    }

    test_fn();

    let events = get_events();
    assert!(!events.is_empty());
}

#[test]
#[serial]
fn test_matches_macro() {
    reset();

    #[trace_borrow]
    fn test_fn() {
        let value = Some(42);
        let result = matches!(value, Some(x) if x > 0);
        assert!(result);
    }

    test_fn();

    let events = get_events();
    assert!(!events.is_empty());
}

#[test]
#[serial]
fn test_write_macro() {
    reset();

    #[trace_borrow]
    fn test_fn() {
        use std::fmt::Write;
        let mut s = String::new();
        write!(&mut s, "Hello, world!").unwrap();
        assert_eq!(s, "Hello, world!");
    }

    test_fn();

    let events = get_events();
    assert!(!events.is_empty());
}

#[test]
#[serial]
fn test_writeln_macro() {
    reset();

    #[trace_borrow]
    fn test_fn() {
        use std::fmt::Write;
        let mut s = String::new();
        writeln!(&mut s, "Line 1").unwrap();
        writeln!(&mut s, "Line 2").unwrap();
        assert!(s.contains("Line 1"));
    }

    test_fn();

    let events = get_events();
    assert!(!events.is_empty());
}

#[test]
#[serial]
fn test_panic_macro() {
    reset();

    #[trace_borrow]
    fn test_fn() -> std::result::Result<(), String> {
        let x = 42;
        if x > 100 {
            panic!("Value too large: {}", x);
        }
        Ok(())
    }

    let _ = test_fn();

    let events = get_events();
    assert!(!events.is_empty());
}

#[test]
#[serial]
fn test_unimplemented_macro() {
    reset();

    #[trace_borrow]
    fn test_fn() -> i32 {
        let x = 42;
        if x < 0 {
            unimplemented!("Negative values not supported");
        }
        x
    }

    let result = test_fn();
    assert_eq!(result, 42);

    let events = get_events();
    assert!(!events.is_empty());
}

#[test]
#[serial]
fn test_todo_macro() {
    reset();

    #[trace_borrow]
    fn test_fn() -> i32 {
        let x = 42;
        if x < 0 {
            todo!("Handle negative values");
        }
        x
    }

    let result = test_fn();
    assert_eq!(result, 42);

    let events = get_events();
    assert!(!events.is_empty());
}

#[test]
#[serial]
fn test_unreachable_macro() {
    reset();

    #[trace_borrow]
    fn test_fn() -> i32 {
        let x = 42;
        match x {
            42 => x,
            _ => unreachable!("x is always 42"),
        }
    }

    let result = test_fn();
    assert_eq!(result, 42);

    let events = get_events();
    assert!(!events.is_empty());
}

// ============================================================================
// COLLECTION MACROS
// ============================================================================

#[test]
#[serial]
fn test_hashmap_macro_pattern() {
    reset();

    #[trace_borrow]
    fn test_fn() {
        use std::collections::HashMap;
        let mut map = HashMap::new();
        map.insert("key1", 1);
        map.insert("key2", 2);
        assert_eq!(map.len(), 2);
    }

    test_fn();

    let events = get_events();
    assert!(!events.is_empty());
}

#[test]
#[serial]
fn test_hashset_macro_pattern() {
    reset();

    #[trace_borrow]
    fn test_fn() {
        use std::collections::HashSet;
        let mut set = HashSet::new();
        set.insert(1);
        set.insert(2);
        set.insert(3);
        assert_eq!(set.len(), 3);
    }

    test_fn();

    let events = get_events();
    assert!(!events.is_empty());
}

#[test]
#[serial]
fn test_btreemap_macro_pattern() {
    reset();

    #[trace_borrow]
    fn test_fn() {
        use std::collections::BTreeMap;
        let mut map = BTreeMap::new();
        map.insert(1, "one");
        map.insert(2, "two");
        assert_eq!(map.len(), 2);
    }

    test_fn();

    let events = get_events();
    assert!(!events.is_empty());
}

// ============================================================================
// CUSTOM MACROS
// ============================================================================

macro_rules! create_variable {
    ($name:ident, $value:expr) => {
        let $name = $value;
    };
}

#[test]
#[serial]
fn test_custom_macro_simple() {
    reset();

    #[trace_borrow]
    fn test_fn() {
        create_variable!(x, 42);
        let y = x + 1; // Use x to ensure it's tracked
        assert_eq!(y, 43);
    }

    test_fn();

    let events = get_events();
    // Should have at least the y variable tracked
    assert!(!events.is_empty());
}

macro_rules! create_vec {
    ($($item:expr),*) => {
        {
            vec![$($item),*]
        }
    };
}

#[test]
#[serial]
fn test_custom_macro_complex() {
    reset();

    #[trace_borrow]
    fn test_fn() {
        let v = create_vec!(1, 2, 3, 4, 5);
        assert_eq!(v.len(), 5);
    }

    test_fn();

    let events = get_events();
    assert!(!events.is_empty());
}

macro_rules! swap_values {
    ($a:expr, $b:expr) => {
        std::mem::swap(&mut $a, &mut $b)
    };
}

#[test]
#[serial]
fn test_custom_macro_with_mutation() {
    reset();

    #[trace_borrow]
    fn test_fn() {
        let mut x = 1;
        let mut y = 2;
        swap_values!(x, y);
        assert_eq!(x, 2);
        assert_eq!(y, 1);
    }

    test_fn();

    let events = get_events();
    assert!(!events.is_empty());
}

macro_rules! nested_macro {
    ($name:ident) => {
        let $name = 100;
    };
}

#[test]
#[serial]
fn test_nested_macros() {
    reset();

    #[trace_borrow]
    fn test_fn() {
        nested_macro!(inner);
        let result = inner + 1; // Use inner to ensure tracking
        assert_eq!(result, 101);
    }

    test_fn();

    let events = get_events();
    // Should have at least the result variable tracked
    assert!(!events.is_empty());
}

// ============================================================================
// MACRO HYGIENE
// ============================================================================

macro_rules! hygienic_macro {
    () => {{
        let hidden = 42;
        hidden
    }};
}

#[test]
#[serial]
fn test_macro_hygiene() {
    reset();

    #[trace_borrow]
    fn test_fn() {
        let result = hygienic_macro!();
        assert_eq!(result, 42);
    }

    test_fn();

    let events = get_events();
    assert!(!events.is_empty());
}

// ============================================================================
// DERIVE MACROS
// ============================================================================

#[derive(Debug, Clone, PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

#[test]
#[serial]
fn test_derive_debug() {
    reset();

    #[trace_borrow]
    fn test_fn() {
        let p = Point { x: 1, y: 2 };
        let s = format!("{:?}", p);
        assert!(s.contains("Point"));
    }

    test_fn();

    let events = get_events();
    assert!(!events.is_empty());
}

#[test]
#[serial]
fn test_derive_clone() {
    reset();

    #[trace_borrow]
    fn test_fn() {
        let p1 = Point { x: 1, y: 2 };
        let p2 = p1.clone();
        assert_eq!(p1, p2);
    }

    test_fn();

    let events = get_events();
    assert!(!events.is_empty());
}

#[derive(Default)]
struct Config {
    value: i32,
}

#[test]
#[serial]
fn test_derive_default() {
    reset();

    #[trace_borrow]
    fn test_fn() {
        let config = Config::default();
        assert_eq!(config.value, 0);
    }

    test_fn();

    let events = get_events();
    assert!(!events.is_empty());
}

// ============================================================================
// ATTRIBUTE MACROS
// ============================================================================

#[test]
#[serial]
fn test_cfg_attribute() {
    reset();

    #[trace_borrow]
    fn test_fn() {
        #[cfg(test)]
        let x = 42;

        #[cfg(not(test))]
        let x = 0;

        assert_eq!(x, 42);
    }

    test_fn();

    let events = get_events();
    assert!(!events.is_empty());
}

#[test]
#[serial]
fn test_allow_attribute() {
    reset();

    #[trace_borrow]
    fn test_fn() {
        #[allow(unused_variables)]
        let unused = 42;

        let used = 100;
        assert_eq!(used, 100);
    }

    test_fn();

    let events = get_events();
    assert!(!events.is_empty());
}

// ============================================================================
// COMPLEX MACRO COMBINATIONS
// ============================================================================

#[test]
#[serial]
fn test_multiple_macros_combined() {
    reset();

    #[trace_borrow]
    fn test_fn() {
        let v = vec![1, 2, 3];
        let s = format!("Vector: {:?}", v);
        println!("{}", s);
        assert!(matches!(v.len(), 3));
    }

    test_fn();

    let events = get_events();
    assert!(!events.is_empty());
    // Should track both v and s
    assert!(events.iter().filter(|e| e.is_new()).count() >= 2);
}

#[test]
#[serial]
fn test_macro_in_match() {
    reset();

    #[trace_borrow]
    fn test_fn() {
        let value = Some(42);
        let result = matches!(value, Some(x) if (40..=50).contains(&x));
        assert!(result);
    }

    test_fn();

    let events = get_events();
    assert!(!events.is_empty());
}

#[test]
#[serial]
fn test_macro_in_closure() {
    reset();

    #[trace_borrow]
    fn test_fn() {
        let v = vec![1, 2, 3];
        let doubled: Vec<_> = v.iter().map(|x| format!("{}", x * 2)).collect();
        assert_eq!(doubled.len(), 3);
    }

    test_fn();

    let events = get_events();
    assert!(!events.is_empty());
}

#[test]
#[serial]
fn test_macro_with_generics() {
    reset();

    #[trace_borrow]
    fn test_fn() {
        let v1 = vec![1, 2, 3];
        let v2 = vec!["a", "b", "c"];
        assert_eq!(v1.len(), v2.len());
    }

    test_fn();

    let events = get_events();
    assert!(!events.is_empty());
}

// ============================================================================
// ERROR HANDLING MACROS
// ============================================================================

#[test]
#[serial]
fn test_try_macro_pattern() {
    reset();

    #[trace_borrow]
    fn test_fn() -> std::result::Result<i32, String> {
        let x: std::result::Result<i32, String> = Ok(42);
        let y = x?;
        Ok(y)
    }

    let result = test_fn();
    assert_eq!(result, Ok(42));

    let events = get_events();
    assert!(!events.is_empty());
}

#[test]
#[serial]
fn test_option_macro_pattern() {
    reset();

    #[trace_borrow]
    fn test_fn() -> Option<i32> {
        let x = Some(42);
        let y = x?;
        Some(y)
    }

    let result = test_fn();
    assert_eq!(result, Some(42));

    let events = get_events();
    assert!(!events.is_empty());
}

// ============================================================================
// ASYNC MACROS
// ============================================================================

#[tokio::test]
#[serial]
async fn test_async_with_macros() {
    reset();

    #[trace_borrow]
    async fn test_fn() {
        let v = vec![1, 2, 3];
        tokio::time::sleep(tokio::time::Duration::from_millis(1)).await;
        assert_eq!(v.len(), 3);
    }

    test_fn().await;

    let events = get_events();
    assert!(!events.is_empty());
}

#[tokio::test]
#[serial]
async fn test_select_macro() {
    reset();

    #[trace_borrow]
    async fn test_fn() {
        let v = vec![1, 2, 3];
        tokio::select! {
            _ = tokio::time::sleep(tokio::time::Duration::from_millis(1)) => {
                assert_eq!(v.len(), 3);
            }
        }
    }

    test_fn().await;

    let events = get_events();
    assert!(!events.is_empty());
}

// ============================================================================
// MACRO EDGE CASES
// ============================================================================

#[test]
#[serial]
fn test_empty_vec_macro() {
    reset();

    #[trace_borrow]
    fn test_fn() {
        let v: Vec<i32> = vec![];
        assert_eq!(v.len(), 0);
    }

    test_fn();

    let events = get_events();
    assert!(!events.is_empty());
}

#[test]
#[serial]
fn test_macro_with_trailing_comma() {
    reset();

    #[trace_borrow]
    fn test_fn() {
        let v = vec![1, 2, 3];
        assert_eq!(v.len(), 3);
    }

    test_fn();

    let events = get_events();
    assert!(!events.is_empty());
}

#[test]
#[serial]
fn test_macro_with_complex_expressions() {
    reset();

    #[trace_borrow]
    fn test_fn() {
        let x = 2;
        let v = vec![x * 2, x * 3, x * 4];
        assert_eq!(v, vec![4, 6, 8]);
    }

    test_fn();

    let events = get_events();
    assert!(!events.is_empty());
}

macro_rules! conditional_code {
    (debug) => {
        "debug"
    };
    (release) => {
        "release"
    };
}

#[test]
#[serial]
fn test_conditional_macro() {
    reset();

    #[trace_borrow]
    fn test_fn() {
        #[cfg(debug_assertions)]
        let mode = conditional_code!(debug);

        #[cfg(not(debug_assertions))]
        let mode = conditional_code!(release);

        assert!(mode == "debug" || mode == "release");
    }

    test_fn();

    let events = get_events();
    assert!(!events.is_empty());
}
